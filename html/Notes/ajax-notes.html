<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>AJAX Notes</title>
    <style>
        li {
            padding: 5px 0;
        }

        body {
            padding: 10px;
        }

        h2 {
            border-bottom: solid black 2px;
        }

        h1, h2 {
            text-align: center;
        }

        p {
            text-indent: 25px;
        }

        code {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-left: 3px solid #f36d33;
            color: #666;
            page-break-inside: avoid;
            font-family: monospace;
            font-size: 15px;
            line-height: 1.6;
            margin-bottom: 1.6em;
            max-width: 100%;
            overflow: auto;
            padding: 1em 1.5em;
            display: block;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
<h1>AJAX</h1>
<p>
    Ajax is a group of interrelated Web development techniques used on the client-side to create asynchronous web
    applications. With Ajax, web applications can send data to and retrieve from a server asynchronously (in the
    background) without interfering with the display and behavior of the existing page. Data can be retrieved using the
    XMLHttpRequest object. Despite the name, the use of XML is not required (JSON is often used in the AJAJ variant),
    and the requests do not need to be asynchronous.
</p>
<p>AJAX is a developer's dream, because you can:</p>
<ul>
    <li>Read data from a web server - after the page has loaded</li>
    <li>Update a web page without reloading the page</li>
    <li>Send data to a web server - in the background</li>
</ul>
<p>Ajax uses a combo of:</p>
<ul>
    <li>A browser built-in XMLHttpRequest object (to request data from a web server) or JSON</li>
    <li>JavaScript and HTML DOM (to display or use the data)ß</li>
</ul>
<p><strong>
    In short;</strong> AJAX is about loading data in the background and displaying it on the webpage, without reloading
    the whole
    page.</p>
<h2>XML</h2>
<ul>
    <li>XML stands for eXtensible Markup Language</li>
    <li>XML is a markup language much like HTML</li>
    <li>XML was designed to store and transport data</li>
    <li>XML was designed to be self-descriptive</li>
    <li>XML was designed to carry data - with focus on what data is</li>
    <li>HTML was designed to display data - with focus on how data looks</li>
    <li>XML tags are not predefined like HTML tags are</li>
    <li>XML documents are formed as element trees.</li>
    <li>An XML tree starts at a root element and branches from the root to child elements.</li>
    <li>All elements can have sub elements (child elements):</li>
    <li>Thousands of XML formats exist, in many different industries, to describe day-to-day data transactions.</li>
</ul>
<p>All modern browsers have a built-in XMLHttpRequest object.</p>
<h3>Example of XML format of a XMLNews document</h3>
<code>
    <?xml version="1.0" encoding="UTF-8"?>
    <nitf>
        <head>
            <title>Colombia Earthquake</title>
        </head>
        <body>
        <headline>
            <hl1>143 Dead in Colombia Earthquake</hl1>
        </headline>
        <byline>
            <bytag>By Jared Kotler, Associated Press Writer</bytag>
        </byline>
        <dateline>
            <location>Bogota, Colombia</location>
            <date>Monday January 25 1999 7:28 ET</date>
        </dateline>
        </body>
    </nitf>
</code>
<h2>JavaScript Object Notation - JSON</h2>
<p>
    JSON is a data-interchange format that is easy for humans to read and write. It is widely used in cloud based
    services and web application programming interfaces (APIs). Object properties in JSON must be double-quoted strings,
    and properties are separated by a commas.
</p>
<code>
    {
    "name1": "value1",
    "name2": "value2"
    }
</code>
<p>The value of a property can be one of the following:</p>
<ul>
    <li>A quoted string</li>
    <li>A number</li>
    <li>An object</li>
    <li>An array</li>
    <li>true or false</li>
    <li>null</li>
</ul>
<p>In the real-world you will most likely not edit these files directly; rather, JSON would most likely be automatically
    generated, or sent and received by a web server.</p>

<h2>Fetch API</h2>
<p>
    Modern Browsers can use Fetch API instead of the XMLHttpRequest Object.
    The Fetch API interface allows web browser to make HTTP requests to web servers.
    If you use the XMLHttpRequest Object, Fetch can do the same in a simpler way.
</p>
<p>
    Fetch provides a better alternative that can be easily used by other technologies such as Service Workers (service
    workers essentially act as proxy servers that sit between web applications, the browser, and the network). Fetch
    also provides a single logical place to define other HTTP-related concepts such as CORS (Cross-Origin Resource
    Sharing is an HTTP-header based mechanism that allows a server to indicate any origins (domain, scheme, or port)
    other than its own from which a browser should permit loading resources. and extensions to HTTP.
</p>
<p>The fetch specification differs from jQuery.ajax() in the following significant ways:</p>
<ul>
    <li>The Promise (the Promise object represents the eventual completion (or failure) of an asynchronous operation and
        its resulting value.) returned from fetch() won’t reject on HTTP error status even if the response is an HTTP
        404 or 500. Instead, as soon as the server responds with headers, the Promise will resolve normally (with the ok
        property of the response set to false if the response isn’t in the range 200–299), and it will only reject on
        network failure or if anything prevented the request from completing.
    </li>
    <li>fetch() won’t send cross-origin cookies unless you set the credentials init option.</li>
</ul>
<p>Example of a basic fetch request:</p>
<code>
    fetch('http://example.com/movies.json')
    <br>&emsp;.then(response => response.json())
    <br>&emsp;.then(data => console.log(data));
</code>
<p>
    Here we are fetching a JSON file across the network and printing it to the console. The simplest use of fetch()
    takes one argument — the path to the resource you want to fetch — and does not directly return the JSON response
    body but instead returns a promise that resolves with a Response object.
</p>
<p>
    The Response object, in turn, does not directly contain the actual JSON response body but is instead a
    representation of the entire HTTP response. So, to extract the JSON body content from the Response object, we use
    the json() method, which returns a second promise that resolves with the result of parsing the response body text as
    JSON.
</p>
<h2>AJAX Requests</h2>
<p>
    The syntax to perform an Ajax request in plain JavaScript can be rather challenging. To save ourselves from that
    complexity, we will be using jQuery to issue Ajax requests. The simplest way to issue an Ajax request is the
    following:
</p>
<code>
    $.ajax("/some-url")
</code>
<p>
    This will issue a GET request to your server, asking for the file stored at /some-url.
</p>
<p>The easiest way to manipulate the Ajax options is to pass a JavaScript object like the following:</p>
<code>
    $.ajax("/some-url", {
    <br>&emsp;type: "POST",
    <br>&emsp;data: {
    <br>&emsp;&emsp;name: "John",
    <br>&emsp;&emsp;location: "Boston"
    <br>&emsp;}
    <br>});
</code>
<p>
    In the above, we are instructing jQuery to send a POST request, along with some additional info to the server.
</p>
<p>
    The Ajax options object has numerous parameters and values it can use. Some of the most common options are:
</p>
<ul>
    <li><strong>type</strong> — The type of HTTP request to send to the server. Can be "GET", "POST", "PUT", or
        "DELETE".
        The default is "GET".
    </li>
    <li><strong>data</strong> — Data to be included with the request. Typically this will be a JavaScript object. If the
        request type is GET the data will be encoded into the URL being requested. Otherwise, it is included with the
        request behind the scenes.
    </li>
    <li><strong>dataType</strong> — The type of data we expect the server to send back from our request. Common options
        are
        "json", "xml", "html", or "text". By default, jQuery will try to guess this value based on the response content.
    </li>
    <li><strong>url</strong> — Rather than passing the request URL as a string to $.ajax() you can just pass a
        JavaScript
        object on its own and include the url option to specify where to send the request. We will see an example of
        this further on.
    </li>
    <li><strong>username & password</strong> — If a server requires a username and password you can specify it using
        these
        parameters.
    </li>
    <li><strong>headers</strong> — an object of whose key value pairs represent custom HTTP headers to send along with
        the request.
    </li>
</ul>
<h3>Handling Responses</h3>
<p>
    It is important to be aware that Ajax requests are done asynchronously. This means that even though the request is
    fired off when we call $.ajax(), JavaScript does not sit and wait for the response to come back. The server could
    reply in a fraction of a second, or it could reply in half a minute!
</p>
<p>
    Just because and AJAX request has been sent, there is no guarantee that is has to come back from the server by the
    time the next line of JS is executed.
</p>
<p>
    A function that we create to be called when some process completes is called a callback function. The primary way to
    attach a callback to your Ajax request is to tack .done() to the end of your request and pass your callback to it,
    like the following:
</p>
<code>
    $.ajax("/some-url").done(function(data, status, jqXhr) {
    &emsp;alert("AJAX call completed successfully!");
    &emsp;console.log("Request status: " + status);
    &emsp;console.log("Data returned from server:");
    &emsp;console.log(data);
    });
</code>
<p>
    <em>.done()</em> is a method that accepts a callback function as an argument. jQuery will then call that function
    once the Ajax request has come back successfully. The callback function, when called, will be passed 3 arguments:
</p>
<ul>
    <li>data: the body of the response from the server</li>
    <li>status: a string indicating the status of the request</li>
    <li>jqXhr: a jQuery object that represents the Ajax request</li>
</ul>
<p>
    If jQuery thinks the server returned a JSON object, the argument will be an object. If jQuery thinks it was text,
    the argument will be a string. You can force a particular data type with the dataType option. We can omit
    parameters, commonly we will only need the <em>data</em> parameter.
</p>
<p>
    There are three different methods you can use to specify callback functions for an Ajax request. They are:
</p>
<ul>
    <li>.done — Takes in a function that is called when the request completes successfully.</li>
    <li>.fail — Takes in a function that is called when a request completed with an error (e.g. the server sent back a
        404).
    </li>
    <li>.always — Takes in a function that is called for both failed and successful requests.</li>
</ul>
<p>
    The function passed to .fail will be called with 3 arguments:
</p>
<ul>
    <li>jqXhr — a jQuery object that represents the Ajax request</li>
    <li>status — a string representing the status of the request</li>
    <li>error — an object that represents the error that occurred, if any</li>
</ul>
<p><em>The callback function attached with .always() will be called with the same arguments the were passed to either
    the .done callback, or the .fail callback, depending on whether the request was successful or not.</em></p>
<p>
    An example combining all three callback types might look like:
</p>
<code>
    $.ajax("/some-url").done(function(data, status, jqXhr) {
    <br>&emsp;alert("Everything went great! Check out the server's response in the console.");
    <br>&emsp;console.log(data);
    <br>}).fail(function(jqXhr, status, error) {
    <br>&emsp;alert("There was an error! Check the console for details");
    <br>&emsp;console.log("Response status: " + status);
    <br>&emsp;console.log("Error object: " + error);
    <br>}).always(function() {
    <br>&emsp;alert("This function always runs!");
    <br>});
</code>

<p>
    You can assign your Ajax request to a variable and then attach callbacks to that variable. Our above example could
    be rewritten as:
</p>
<code>
    &emsp;// Assign to variable
    <br>var jqXhr = $.ajax("/some-url");
    <br>
    <br>// Attach callback functions individually
    <br>jqXhr.done(function(data, status, jqXhr) {
    <br>&emsp;alert("Everything went great!");
    <br>});
    <br>
    <br>jqXhr.fail(function(jqXhr, status, error) {
    <br>&emsp;alert("There was an error!");
    <br>});
    <br>
    <br>jqXhr.always(function() {
    <br>&emsp;alert("And we're done!");
    <br>});
</code>
<p>
    Remember that any anonymous function can be replaced with a named function, and as our code starts to get more
    complex, it usually makes sense to do so.
</p>
<h3>Get & Post Shorthand</h3>
<code>
    $.get("/users", {
    <br>&emsp;limit: 10,
    <br>&emsp;offset: 20
    <br>}).done(function(data) {
    <br>&emsp;// do something with the data
    <br>});

</code>
<p>Would be the same as:</p>
<code>
    $.ajax({
    <br>&emsp;url: "/users",
    <br>&emsp;type: "GET",
    <br>&emsp;data: {
    <br>&emsp;&emsp;limit: 10,
    <br>&emsp;&emsp;offset: 20
    <br>&emsp;}
    <br>}).done(function(data) {
    <br>&emsp;// do something with the data
    <br>});
</code>
<p>Post shorthand:</p>
<code>
    $.post("/address/save", {
    <br>&emsp;first_name: "George",
    <br>&emsp;last_name: "Weathers",
    <br>&emsp;city: "Denver",
    <br>&emsp;state: "CO"
    <br>}).done(function(data) {
    <br>&emsp;// do something with the response
    <br>});
</code>
</body>


</html>