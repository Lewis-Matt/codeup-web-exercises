<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<h2><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing">MDN Article</a></h2>
<p>
    JS is single-threaded (only one thing can happen at a time, on a single main thread). Synchronous functionality
    means that while each operation is being processed, nothing else can happen.
</p>
<p>
    Asynchronous code allow things to happen while we wait for another piece of code's response (such as a response
    from a web API).
</p>
<p>
<p>There are two types of async; callbacks (old style) and promises (new)</p>
<p>callback example:</p>
<code>btn.addEventListener('click', () => { alert('I've been clicked!')}); </code> <br>
<p>When we pass a callback function as an argument to another function, we are only passing the function's reference
    as an argument, i.e, the callback function is not executed immediately. It is “called back” (hence the name)
    asynchronously somewhere inside the containing function’s body.
</p>
<p><em>Not all callbacks are async: using array.forEach(function(){}) to loop through an array is synchronous</em></p>
<p>
    Promises are the new style of async code that you'll see used in modern Web APIs. A good example is the fetch()
    API, which is basically like a modern, more efficient version of XMLHttpRequest.
</p>
<p>
    The promise is an object representing the completion or failure of the async operation. It represents an
    intermediate state, as it were. In essence, it's the browser's way of saying "I promise to get back to you with
    the answer as soon as I can," hence the name "promise."
</p>
<p>
    However, promises are specifically made for handling async operations, and have many advantages over old-style
    callbacks:
</p>
<ul>
    <li>You can chain multiple async operations together using multiple .then() operations, passing the result of one
        into the next one as an input.
    </li>
    <li>Promise callbacks are always called in the strict order they are placed in the event queue.</li>
    <li>Error handling is much better — all errors are handled by a single .catch() block at the end of the block,
        rather than being individually handled in each level of the "pyramid".
    </li>
</ul>
</body>
</html>